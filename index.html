<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Wave Defender ‚Äî One-by-One Mode (5 min)</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#061226;
    --panel:#0b2030;
    --accent:#ffd755;
    --accent2:#55ddff;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#031229,#021018); font-family:"Press Start 2P", monospace; color:#fff}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:12px;gap:8px;}
  canvas{background:linear-gradient(180deg,#02101a,#011018); image-rendering: pixelated; border:6px solid #07263a; box-shadow:0 8px 40px rgba(0,0,0,0.6); border-radius:8px;}
  .hud{display:flex;gap:12px;align-items:center; font-size:11px; text-shadow:0 0 6px rgba(0,0,0,0.6)}
  .hud .box{background:rgba(0,0,0,0.35); padding:8px 10px;border-radius:6px;border:2px solid rgba(255,255,255,0.03)}
  .controls{margin-top:8px; width:360px; max-width:92%; display:flex; gap:6px; justify-content:center; flex-wrap:wrap}
  .btn{background:linear-gradient(180deg,#ffd77f,#ffb84d); border:3px solid #4d2b00; padding:8px 10px; border-radius:6px; font-size:11px; cursor:pointer; box-shadow: 0 6px 0 #8a5a0a;}
  .choiceBtn{background:linear-gradient(180deg,#6fe6ff,#38b0d7); color:#02121b; border:3px solid #05323b; padding:6px 8px; font-size:10px; border-radius:6px; box-shadow:0 6px 0 #034d57;}
  .choiceBtn.correct{background:linear-gradient(180deg,#9df59a,#51c65d); box-shadow:0 6px 0 #2b8a2f;}
  .choiceBtn.wrong{background:linear-gradient(180deg,#ff9aa0,#ff5968); box-shadow:0 6px 0 #8a2b3a;}
  .overlay{position:fixed; left:50%; top:50%; transform:translate(-50%,-50%); z-index:60; background:linear-gradient(180deg,#021825,#041833); padding:16px; border-radius:10px; width:92%; max-width:760px; border:4px solid rgba(255,255,255,0.03)}
  .title{font-size:14px; color:var(--accent); text-align:center; margin-bottom:6px}
  .sub{font-size:10px; color:#bcd; text-align:center; margin-bottom:10px}
  .questionBox{background:#021827; padding:10px; border-radius:6px; border:2px solid rgba(255,255,255,0.03); margin-bottom:8px; font-size:11px; color:#ffd}
  footer{font-size:10px;color:#89b; margin-top:8px}
  @media (max-width:520px){
    .hud{font-size:9px}
    .btn{padding:6px 8px;font-size:10px}
    .choiceBtn{font-size:10px;padding:6px 8px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div class="box">SCORE: <span id="score">0</span></div>
    <div class="box">LIVES: <span id="lives">5</span></div>
    <div class="box">TIME LEFT: <span id="globalTimer">05:00</span></div>
    <div class="box">Q TIME: <span id="questionTimer">15</span>s</div>
    <div class="box">ENEMY: <span id="enemyName">‚Äî</span></div>
  </div>

  <canvas id="game" width="360" height="640"></canvas>

  <div class="controls" id="controls">
    <!-- choices will appear here -->
  </div>

  <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:6px">
    <button class="btn" id="startBtn">‚ñ∂Ô∏è START (5 ‡∏ô‡∏≤‡∏ó‡∏µ)</button>
    <button class="btn" id="pauseBtn">‚è∏Ô∏è PAUSE</button>
    <button class="btn" id="helpBtn">‚ùì HELP</button>
  </div>

  <footer>One-by-one Pixel Monsters ‚Ä¢ ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏Ñ‡∏•‡∏∑‡πà‡∏ô ‡∏°.5 (‡πÄ‡∏ó‡∏≠‡∏°1) ‚Ä¢ ‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ 15 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏ï‡πà‡∏≠‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°</footer>
</div>

<!-- overlay root -->
<div id="overlayRoot" style="position:fixed;left:0;top:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;z-index:70"></div>

<script>
/* --------------------------
   CONFIG & DATA
   -------------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let audioCtx = null;
function ensureAudio(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function beep(freq=440, time=0.08, type='sine', vol=0.12){
  try{
    ensureAudio();
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    setTimeout(()=>{ o.stop(); }, time*1000);
  }catch(e){}
}

// game state & stats
let state = {
  running:false,
  score:0,
  lives:5,
  enemies:[],
  particles:[],
  anim:0,
  currentEnemy:null, // single active enemy
  awaitingAnswer:false,
  weaponFreq:null,
  // timers
  globalTime:300, // 5 minutes in seconds
  questionTime:15,
  questionInterval:null,
  globalInterval:null,
  // stats for summary
  correctCount:0,
  wrongCount:0,
  unansweredCount:0,
  encounteredQuestions: []
};

// numbers to ensure lambda integer
const easyF = [2,4,5,8,10,20,25];
const easyV = [40,50,60,80,100,120,160,200,240,300];
const bossF = [6,12,15,18,24];
const bossV = [90,108,144,180,216,270];

const monsters = [
  {id:'plasma_fiend', name:'Plasma Fiend', thai:'‡∏õ‡∏µ‡∏®‡∏≤‡∏à‡∏û‡∏•‡∏≤‡∏™‡∏°‡∏≤', color:'#ff5d5d', points:80},
  {id:'neon_squid', name:'Neon Squid', thai:'‡∏´‡∏°‡∏∂‡∏Å‡∏ô‡∏µ‡∏≠‡∏≠‡∏ô', color:'#6bf5ff', points:70},
  {id:'ember_wyrm', name:'Ember Wyrm', thai:'‡πÄ‡∏ß‡∏¥‡∏£‡πå‡∏°‡πÑ‡∏ü', color:'#ffb86b', points:75},
  {id:'void_eye', name:'Void Eye', thai:'‡∏ï‡∏≤‡∏ß‡∏≠‡∏¢‡∏î‡πå', color:'#b86bff', points:85},
  {id:'king_titan', name:'Star Titan', thai:'‡∏à‡∏±‡∏Å‡∏£‡∏û‡∏£‡∏£‡∏î‡∏¥‡πÅ‡∏´‡πà‡∏á‡∏î‡∏≤‡∏ß', color:'#4bff9e', points:220, boss:true}
];

const theoryQuestions = [
  {q:'‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà (frequency) ‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á‡∏≠‡∏∞‡πÑ‡∏£?', choices:[
      '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏±‡πà‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÄ‡∏ß‡∏•‡∏≤',
      '‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏¢‡∏≠‡∏î‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏™‡∏≠‡∏á‡∏¢‡∏≠‡∏î',
      '‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà',
      '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô'
    ], ans:0},
  {q:'‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (wavelength) ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£?', choices:[
      '‡∏£‡∏∞‡∏¢‡∏∞‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡∏ö‡∏ô‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏™‡∏≠‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ñ‡∏±‡∏î‡∏Å‡∏±‡∏ô',
      '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏±‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ',
      '‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô',
      '‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô'
    ], ans:0},
  {q:'‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô ‡πÇ‡∏î‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏ó‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏° ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£?', choices:[
      '‡∏™‡∏±‡πâ‡∏ô‡∏•‡∏á',
      '‡∏¢‡∏≤‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô',
      '‡∏Ñ‡∏á‡πÄ‡∏î‡∏¥‡∏°',
      '‡πÑ‡∏°‡πà‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ô‡∏ò‡πå'
    ], ans:0},
  {q:'‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ä‡∏ô‡∏¥‡∏î‡πÉ‡∏î?', choices:[
      '‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ï‡∏≤‡∏°‡∏¢‡∏≤‡∏ß (longitudinal)',
      '‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ï‡∏≤‡∏°‡∏Ç‡∏ß‡∏≤‡∏á (transverse)',
      '‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ô‡∏¥‡πà‡∏á (standing)',
      '‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡πÅ‡∏°‡πà‡πÄ‡∏´‡∏•‡πá‡∏Å‡πÑ‡∏ü‡∏ü‡πâ‡∏≤'
    ], ans:0},
  {q:'‡πÅ‡∏≠‡∏°‡∏û‡∏•‡∏¥‡∏à‡∏π‡∏î (amplitude) ‡∏ö‡πà‡∏á‡∏ö‡∏≠‡∏Å‡∏≠‡∏∞‡πÑ‡∏£?', choices:[
      '‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏™‡∏°‡∏î‡∏∏‡∏•',
      '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ',
      '‡∏£‡∏∞‡∏¢‡∏∞‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏¢‡∏≠‡∏î‡∏Ñ‡∏•‡∏∑‡πà‡∏ô',
      '‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô'
    ], ans:0}
];

/* --------------------------
   PIXEL HELPERS
   -------------------------- */
function pixRect(x,y,w,h,color){
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x),Math.round(y),Math.round(w),Math.round(h));
}
function drawText(text,x,y,size=8,color='#fff',align='left'){
  ctx.fillStyle = color;
  ctx.font = `${size}px "Press Start 2P"`;
  ctx.textAlign = align;
  ctx.fillText(text, x, y);
}

/* --------------------------
   UI: choices render
   -------------------------- */
const controls = document.getElementById('controls');
function clearChoices(){ controls.innerHTML = ''; }
function renderQuestion(q){
  clearChoices();
  if(!q) return;
  const qBox = document.createElement('div');
  qBox.className = 'questionBox';
  qBox.style.width='100%';
  qBox.innerHTML = `<div style="font-size:11px;color:#ffea99;margin-bottom:6px">${escapeHtml(q.text).replace(/\n/g,'<br>')}</div>`;
  controls.appendChild(qBox);
  q.choices.forEach((ch, idx)=>{
    const b = document.createElement('button');
    b.className = 'choiceBtn';
    b.style.minWidth='150px';
    b.style.margin='4px';
    b.innerText = (q.type==='calc' ? `Œª = ${ch} m` : ch);
    b.onclick = ()=> handleAnswer(ch, idx, b);
    controls.appendChild(b);
  });
}

/* --------------------------
   QUESTIONS & ENEMY
   -------------------------- */
function spawnEnemy(){
  // ensure single enemy at a time
  if(state.currentEnemy) return;
  // boss every 6th defeated
  const isBoss = ((state.defeated || 0) + 1) % 6 === 0 && Math.random() < 0.85;
  const choiceList = isBoss ? monsters.filter(m=>m.boss) : monsters.filter(m=>!m.boss);
  let m = choiceList[Math.floor(Math.random()*choiceList.length)];
  if(isBoss && !m) m = monsters[4];

  // choose v,f such that lambda integer
  let f, v;
  if(m.boss){
    f = bossF[Math.floor(Math.random()*bossF.length)];
    v = bossV[Math.floor(Math.random()*bossV.length)];
  } else {
    f = easyF[Math.floor(Math.random()*easyF.length)];
    const candidates = easyV.filter(val => val % f === 0);
    v = candidates[Math.floor(Math.random()*candidates.length)];
    if(!v){ v = easyV[0]; while(v % f !== 0) v += easyV[0]; }
  }
  const lambda = v / f;
  const e = {
    id: Math.random().toString(36).slice(2,8),
    prototype: m,
    x: W/2,
    y: -40,
    vy: 0.6 + (m.boss?0.2:0.0),
    color: m.color,
    points: m.points,
    f, v, lambda,
    hp: m.boss?3:1,
    isBoss: !!m.boss,
    name: `${m.name} ‚Äî ${m.thai}`
  };
  state.currentEnemy = e;
  document.getElementById('enemyName').textContent = e.name;

  // prepare question (calc 70% for boss, 55% otherwise)
  const prob = e.isBoss ? 0.75 : 0.55;
  if(Math.random() < prob){
    const text = `‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô Œª ‡πÇ‡∏î‡∏¢ Œª = v / f\nv = ${e.v} m/s, f = ${e.f} Hz`;
    const correct = e.lambda;
    const choices = new Set([correct]);
    while(choices.size < 4){
      const delta = (Math.floor(Math.random()*5)-2);
      let w = correct + delta;
      if(w <= 0) w = correct + Math.abs(delta) + 1;
      choices.add(w);
    }
    const arr = shuffle(Array.from(choices));
    state.currentQuestion = {type:'calc', text, choices:arr, correct};
  } else {
    const q = theoryQuestions[Math.floor(Math.random()*theoryQuestions.length)];
    const arr = shuffle(q.choices.slice());
    state.currentQuestion = {type:'theory', text:q.q, choices:arr, correctIndex: arr.indexOf(q.choices[q.ans])};
  }

  // record encountered for summary
  state.encounteredQuestions.push({
    enemyName: e.name,
    q: state.currentQuestion
  });

  // stop enemy movement to let player calculate
  state.currentEnemy.vy = 0;
  state.awaitingAnswer = true;
  startQuestionTimer();
  renderQuestion(state.currentQuestion);
  beep(880, 0.06, 'square', 0.08);
}

/* --------------------------
   per-question timer & global timer
   -------------------------- */
let questionTimerHandle = null;
function startQuestionTimer(){
  // reset timer
  state.questionTime = 15;
  document.getElementById('questionTimer').textContent = state.questionTime;
  if(questionTimerHandle) clearInterval(questionTimerHandle);
  questionTimerHandle = setInterval(()=>{
    state.questionTime--;
    document.getElementById('questionTimer').textContent = state.questionTime;
    if(state.questionTime <= 0){
      clearInterval(questionTimerHandle);
      questionTimeout();
    }
  }, 1000);
}

function stopQuestionTimer(){
  if(questionTimerHandle) { clearInterval(questionTimerHandle); questionTimerHandle = null; }
  document.getElementById('questionTimer').textContent = state.questionTime;
}

function questionTimeout(){
  // treat as unanswered
  state.awaitingAnswer = false;
  state.unansweredCount++;
  stopQuestionTimer();
  flashWrong();
  // penalty
  state.lives = Math.max(0, state.lives - 1);
  updateHUD();
  // if lives 0 -> end
  if(state.lives <= 0){ endGame(); return; }
  // allow enemy to be removed (simulate escape)
  setTimeout(()=> {
    // enemy escapes / gets removed
    if(state.currentEnemy){
      createPixelBurst(state.currentEnemy.x, state.currentEnemy.y, '#ff8a8a', 14);
      state.currentEnemy = null;
      clearChoices();
      // next spawn after short delay
      setTimeout(()=> { if(state.running) spawnEnemy(); }, 600);
    }
  }, 600);
}

/* --------------------------
   handle answer
   -------------------------- */
function handleAnswer(choice, idx, btnEl){
  if(!state.awaitingAnswer) return;
  state.awaitingAnswer = false;
  stopQuestionTimer();
  const q = state.currentQuestion;
  let correct = false;
  if(q.type === 'calc'){
    correct = (Math.abs(choice - q.correct) < 1e-9);
  } else {
    correct = (idx === q.correctIndex);
  }

  const btns = Array.from(document.querySelectorAll('.choiceBtn'));
  btns.forEach(b => b.disabled = true);

  if(correct){
    btnEl.classList.add('correct');
    state.correctCount++;
    // enemy damaged / destroyed
    if(state.currentEnemy){
      createPixelBurst(state.currentEnemy.x, state.currentEnemy.y, state.currentEnemy.color, 18);
      state.currentEnemy.hp--;
      if(state.currentEnemy.hp <= 0){
        // kill
        state.score += state.currentEnemy.points;
        state.defeated = (state.defeated || 0) + 1;
        state.currentEnemy = null;
        beep(1200, 0.12, 'sawtooth', 0.12);
      } else {
        // damaged but not dead
        state.score += Math.round(state.currentEnemy.points / 2);
        beep(900, 0.08, 'square', 0.09);
      }
    } else {
      state.score += 20;
      beep(900, 0.08, 'square', 0.09);
    }
  } else {
    btnEl.classList.add('wrong');
    state.wrongCount++;
    state.lives = Math.max(0, state.lives - 1);
    state.score = Math.max(0, state.score - 20);
    flashWrong();
    beep(220, 0.12, 'sine', 0.14);
    // reveal correct button after short delay
    setTimeout(()=>{
      const correctIdx = (q.type==='calc') ? q.choices.indexOf(q.correct) : q.correctIndex;
      if(typeof correctIdx === 'number' && btns[correctIdx]) btns[correctIdx].classList.add('correct');
    }, 400);
    if(state.lives <= 0){ endGame(); return; }
  }

  updateHUD();
  // after short delay, clear and spawn next
  setTimeout(()=>{
    state.awaitingAnswer = false;
    clearChoices();
    // spawn next enemy after small delay
    if(state.running){
      setTimeout(()=> spawnEnemy(), 500);
    }
  }, 700);
}

/* --------------------------
   HUD & summary
   -------------------------- */
function updateHUD(){
  document.getElementById('score').textContent = state.score;
  document.getElementById('lives').textContent = state.lives;
  const mm = Math.floor(state.globalTime / 60).toString().padStart(2,'0');
  const ss = (state.globalTime % 60).toString().padStart(2,'0');
  document.getElementById('globalTimer').textContent = `${mm}:${ss}`;
  document.getElementById('enemyName').textContent = state.currentEnemy ? state.currentEnemy.name : '‚Äî';
}

/* --------------------------
   particle & pixel effects
   -------------------------- */
function createPixelBurst(x,y,color,count=14){
  for(let i=0;i<count;i++){
    state.particles.push({
      x: x + (Math.random()-0.5)*30,
      y: y + (Math.random()-0.5)*30,
      vx:(Math.random()-0.5)*3,
      vy:(Math.random()-0.5)*3,
      life:30 + Math.random()*30,
      color
    });
  }
}

/* --------------------------
   wrong flash
   -------------------------- */
function flashWrong(){
  // small screen flash using canvas overlay rect
  const prev = ctx.globalAlpha;
  ctx.globalAlpha = 0.2;
  ctx.fillStyle = '#ff6b6b';
  ctx.fillRect(0,0,W,H);
  ctx.globalAlpha = prev;
}

/* --------------------------
   render loop (pixel art)
   -------------------------- */
function render(){
  // clear
  ctx.fillStyle = '#011022';
  ctx.fillRect(0,0,W,H);
  // star background
  for(let i=0;i<45;i++){
    const sx = (i*53 + (state.anim*3)) % W;
    const sy = ((i*37 + (state.anim*2)) % H);
    pixRect((sx)%W, (sy)%H, 1,1, (i%7==0?'#9fe6ff':'#29445a'));
  }
  // draw current enemy (center)
  if(state.currentEnemy){
    const e = state.currentEnemy;
    // simple pixel monster with stripes
    const w = e.isBoss ? 48 : 32;
    const h = e.isBoss ? 36 : 24;
    // body stripes
    const rows = Math.floor(h/4);
    for(let r=0;r<rows;r++){
      const shade = shadeColor(e.color, -r*3 - (e.isBoss?6:0));
      pixRect(e.x - w/2, e.y - h/2 + r*4, w, 3, shade);
    }
    // eyes
    pixRect(e.x - 8, e.y - 6, 4,4, '#000');
    pixRect(e.x + 6, e.y - 6, 4,4, '#000');
    // tentacle pixels for some
    if(!e.isBoss){
      for(let t=0;t<3;t++){
        pixRect(e.x - w/2 + 4 + t*8, e.y + h/2 - 2, 4,4, shadeColor(e.color, -15));
      }
    } else {
      // boss extra eyes
      pixRect(e.x - 18, e.y - 8, 4,4, '#000');
      pixRect(e.x + 14, e.y - 8, 4,4, '#000');
    }
  } else {
    // if no enemy, show "incoming" text
    drawText('NEXT MONSTER...', W/2, 80, 8, '#ffd07a', 'center');
  }

  // draw player ship bottom center
  const px = W/2, py = H - 72;
  pixRect(px-14, py-6, 28,6, '#55d6ff');
  pixRect(px-12, py-12, 24,6, '#ffd66b');
  pixRect(px-6, py-18, 12,6, '#ff9e56');
  pixRect(px-4, py-14, 8,4, '#05323b');

  // draw particles
  for(let i=state.particles.length-1;i>=0;i--){
    const p = state.particles[i];
    pixRect(p.x, p.y, 2,2, p.color);
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.06;
    p.vx *= 0.99;
    p.vy *= 0.99;
    p.life--;
    if(p.life <= 0) state.particles.splice(i,1);
  }

  // HUD inside canvas little
  drawText('Œª = v / f', 8, 14, 9, '#ffdba6', 'left');
  drawText('‡∏ï‡∏≠‡∏ö‡πÉ‡∏´‡πâ‡∏ó‡∏±‡∏ô 15s', W-8, 14, 9, '#a6d8ff', 'right');

  state.anim++;
}

/* --------------------------
   game update (timers & spawn)
   -------------------------- */
function gameStep(){
  if(!state.running) return;
  // global timer tick handled separately
  // if no current enemy, spawn one
  if(!state.currentEnemy && !state.awaitingAnswer){
    spawnEnemy();
  }
  // if currentEnemy exists and not awaitingAnswer, move it slowly down (escape)
  if(state.currentEnemy && !state.awaitingAnswer){
    state.currentEnemy.y += (0.6 + (state.currentEnemy.isBoss?0.25:0.0));
    if(state.currentEnemy.y > H - 140){
      // enemy reached bottom -> player loses life
      createPixelBurst(state.currentEnemy.x, state.currentEnemy.y, '#ff8a8a', 16);
      state.currentEnemy = null;
      state.lives = Math.max(0, state.lives - 1);
      updateHUD();
      if(state.lives <= 0){ endGame(); return; }
    }
  }
  updateHUD();
  render();
  requestAnimationFrame(gameStep);
}

/* --------------------------
   global timer controls
   -------------------------- */
let globalTimerHandle = null;
function startGlobalTimer(){
  if(globalTimerHandle) clearInterval(globalTimerHandle);
  globalTimerHandle = setInterval(()=>{
    state.globalTime--;
    updateHUD();
    if(state.globalTime <= 0){
      clearInterval(globalTimerHandle);
      endGame();
    }
  }, 1000);
}
function stopGlobalTimer(){
  if(globalTimerHandle) clearInterval(globalTimerHandle);
  globalTimerHandle = null;
}

/* --------------------------
   game control: start / pause / end
   -------------------------- */
document.getElementById('startBtn').addEventListener('click', ()=>{
  startGame();
});
document.getElementById('pauseBtn').addEventListener('click', ()=>{
  state.running = !state.running;
  if(state.running){
    document.getElementById('pauseBtn').innerText = '‚è∏Ô∏è PAUSE';
    startGlobalTimer();
    gameStep();
  } else {
    document.getElementById('pauseBtn').innerText = '‚ñ∂Ô∏è RESUME';
    stopGlobalTimer();
  }
});
document.getElementById('helpBtn').addEventListener('click', ()=> showHelp());

function startGame(){
  // reset
  state.running = true;
  state.score = 0; state.lives = 5; state.enemies = []; state.particles = []; state.currentEnemy = null;
  state.correctCount = 0; state.wrongCount = 0; state.unansweredCount = 0; state.defeated = 0;
  state.encounteredQuestions = [];
  state.globalTime = 300; state.questionTime = 15;
  updateHUD();
  clearChoices();
  // start timers & loop
  startGlobalTimer();
  gameStep();
  beep(880, 0.06, 'square', 0.08);
  document.getElementById('startBtn').innerText = '‚Üª RESTART';
}

function endGame(){
  // stop everything
  state.running = false;
  stopGlobalTimer();
  stopQuestionTimer();
  // show summary overlay
  const overlay = document.createElement('div');
  overlay.className = 'overlay';
  overlay.innerHTML = `
    <div style="text-align:center">
      <div class="title">üèÅ TIME'S UP / GAME OVER</div>
      <div class="sub">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô: ${state.score} &nbsp;|&nbsp; ‡∏õ‡∏£‡∏≤‡∏ö: ${state.defeated || 0}</div>
      <div style="background:#021827;padding:10px;border-radius:8px;margin-top:8px;font-size:11px;color:#b
      <div style="background:#021827;padding:10px;border-radius:8px;margin-top:8px;font-size:11px;color:#bcd;text-align:left">
          <div style="font-weight:bold;color:#ffd07a">‡∏™‡∏£‡∏∏‡∏õ‡∏™‡∏±‡πâ‡∏ô ‡πÜ ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (‡∏°.5 ‡πÄ‡∏ó‡∏≠‡∏°1)</div>
          <div style="margin-top:6px">
            ‡∏™‡∏π‡∏ï‡∏£: <strong>Œª = v / f</strong><br>
            Œª = ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (m), v = ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (m/s), f = ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà (Hz).<br>
            ‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô (‡πÄ‡∏°‡∏∑‡πà‡∏≠ v ‡∏Ñ‡∏á‡∏ó‡∏µ‡πà) ‚Üí ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏à‡∏∞‡∏™‡∏±‡πâ‡∏ô‡∏•‡∏á.<br>
          </div>
          <div style="margin-top:8px;font-weight:bold;color:#a6d8ff">‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡πà‡∏ô</div>
          <div>‡∏ï‡∏≠‡∏ö‡∏ñ‡∏π‡∏Å: ${state.correctCount} &nbsp;|&nbsp; ‡∏ï‡∏≠‡∏ö‡∏ú‡∏¥‡∏î: ${state.wrongCount} &nbsp;|&nbsp; ‡πÑ‡∏°‡πà‡∏ï‡∏≠‡∏ö: ${state.unansweredCount}</div>
          <div style="margin-top:8px">
            ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏à‡∏≠:
            <ul style="text-align:left; margin:6px 0 0 16px; font-size:12px; color:#fff">
              ${state.encounteredQuestions.slice(-6).map(it => `<li><strong>${it.enemyName}</strong>: ${escapeHtml(it.q.text).replace(/\n/g,' ')} </li>`).join('')}
            </ul>
          </div>
        </div>
        <div style="margin-top:12px;">
          <button class="btn" id="playAgain">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button>
        </div>
      </div>
    `;
  showOverlayElement(overlay);
  document.getElementById('playAgain').addEventListener('click', ()=>{
    hideOverlay(); startGame();
  });
  beep(160, 0.35, 'sine', 0.15);
}

/* --------------------------
   overlay helpers
   -------------------------- */
const overlayRoot = document.getElementById('overlayRoot');
function showHelp(){
  const html = `
    <div style="padding:8px;color:#bcd">
      <div class="title">‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô</div>
      <div class="sub">‡∏®‡∏±‡∏ï‡∏£‡∏π‡πÇ‡∏ú‡∏•‡πà‡∏ó‡∏µ‡∏•‡∏∞‡∏ï‡∏±‡∏ß ‚Äî ‡∏Ñ‡∏∏‡∏ì‡∏°‡∏µ 15 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö</div>
      <div style="background:#021827;padding:8px;border-radius:6px;margin-top:8px;font-size:11px">
        <p>‚Ä¢ ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏•‡πà‡∏ô‡∏£‡∏ß‡∏°: 5 ‡∏ô‡∏≤‡∏ó‡∏µ (300 s).<br>
           ‚Ä¢ ‡∏ï‡∏≠‡∏ö‡∏ñ‡∏π‡∏Å ‚Üí ‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡∏®‡∏±‡∏ï‡∏£‡∏π / ‡πÑ‡∏î‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô<br>
           ‚Ä¢ ‡∏ï‡∏≠‡∏ö‡∏ú‡∏¥‡∏î‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ï‡∏≠‡∏ö ‚Üí ‡πÄ‡∏™‡∏µ‡∏¢‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï 1 ‡∏´‡∏ô‡πà‡∏ß‡∏¢<br>
           ‚Ä¢ ‡∏ö‡∏≠‡∏™‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≠‡∏ö‡∏´‡∏•‡∏≤‡∏¢‡∏Ñ‡∏£‡∏±‡πâ‡∏á (HP 3)</p>
        <p>‡∏™‡∏π‡∏ï‡∏£‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: Œª = v / f</p>
      </div>
      <div style="text-align:center;margin-top:8px"><button class="btn" id="closeHelp">‡∏õ‡∏¥‡∏î</button></div>
    </div>
  `;
  showOverlay(html);
  document.getElementById('closeHelp').addEventListener('click', hideOverlay);
}
function showOverlay(html){
  overlayRoot.style.display='flex';
  overlayRoot.innerHTML = `<div class="overlay">${html}</div>`;
}
function showOverlayElement(el){
  overlayRoot.style.display='flex';
  overlayRoot.innerHTML = '';
  overlayRoot.appendChild(el);
}
function hideOverlay(){ overlayRoot.style.display='none'; overlayRoot.innerHTML = ''; }

/* --------------------------
   utilities
   -------------------------- */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a }
function shadeColor(hex, percent) {
  const f = hex.slice(1);
  const t = percent < 0 ? 0 : 255;
  const p = Math.abs(percent) / 100;
  const R = parseInt(f.substring(0,2),16);
  const G = parseInt(f.substring(2,4),16);
  const B = parseInt(f.substring(4,6),16);
  const newR = Math.round((t - R)*p) + R;
  const newG = Math.round((t - G)*p) + G;
  const newB = Math.round((t - B)*p) + B;
  return `rgb(${newR},${newG},${newB})`;
}
function escapeHtml(s){ return s.replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m] }) }

/* --------------------------
   start with title screen drawn on canvas
   -------------------------- */
function drawTitleScreen(){
  ctx.fillStyle = '#011022';
  ctx.fillRect(0,0,W,H);
  drawText('PIXEL WAVE DEFENDER', W/2, 100, 10, '#ffd07a', 'center');
  drawText('ONE-BY-ONE MODE ‚Äî 5 ‡∏ô‡∏≤‡∏ó‡∏µ', W/2, 140, 7, '#a6d8ff', 'center');
  // ship preview pixels
  for(let yc=0; yc<5; yc++){
    for(let xc=0; xc<20; xc++){
      const x = 40 + xc*6; const y = 180 + yc*6;
      if((xc+yc)%3===0) pixRect(x,y,4,4, ['#ff5d5d','#ffd66b','#6bf5ff','#b86bff'][Math.floor(Math.random()*4)]);
    }
  }
  drawText('‡∏Å‡∏î START ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°', W/2, H-60, 8, '#ffd07a', 'center');
}
drawTitleScreen();

/* --------------------------
   initial HUD update
   -------------------------- */
updateHUD();
</script>
</body>
</html>
