<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Pixel Wave Defender ‚Äî ‡πÄ‡∏Å‡∏°‡∏Ñ‡∏•‡∏∑‡πà‡∏ô ‡∏°.5</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#081029;
    --panel:#0e1a2b;
    --accent:#ffdd55;
    --accent2:#55ddff;
    --ui:#ffd07a;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071026 0%, #03101a 100%); font-family:"Press Start 2P", monospace; color:#fff}
  .wrap{display:flex;flex-direction:column;align-items:center;padding:12px;gap:8px;}
  canvas{background:linear-gradient(180deg,#071026,#02101a); image-rendering: pixelated; border:6px solid #0b2944; box-shadow:0 8px 30px rgba(0,0,0,0.6); border-radius:8px;}
  .hud{display:flex;gap:18px;align-items:center; font-size:11px; text-shadow:0 0 6px rgba(0,0,0,0.6)}
  .hud .box{background:rgba(0,0,0,0.4); padding:8px 10px;border-radius:6px;border:2px solid rgba(255,255,255,0.05)}
  .controls{margin-top:8px; width:900px; max-width:92%; display:flex; gap:10px; justify-content:center; flex-wrap:wrap}
  .btn{
    background:linear-gradient(180deg,#ffde7a,#ffb84d);
    border:3px solid #331a00; padding:8px 12px; border-radius:6px;
    font-size:12px; cursor:pointer; box-shadow: 0 6px 0 #b36a00, inset 0 -6px 0 rgba(0,0,0,0.08);
    transition:transform .08s;
  }
  .btn:active{transform:translateY(3px); box-shadow:0 3px 0 #b36a00;}
  .choiceBtn{background:linear-gradient(180deg,#55ddff,#2aa7d7); color:#02121b; border:3px solid #05323b; padding:6px 10px; font-size:12px; border-radius:6px; box-shadow:0 6px 0 #034d57;}
  .choiceBtn.correct{background:linear-gradient(180deg,#9df59a,#51c65d); box-shadow:0 6px 0 #2b8a2f;}
  .choiceBtn.wrong{background:linear-gradient(180deg,#ff8aa1,#ff4a6a); box-shadow:0 6px 0 #8a2b3a;}
  .overlay{
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:20;
    background:linear-gradient(180deg, rgba(3,10,20,0.98), rgba(6,12,22,0.98)); padding:18px; border-radius:10px; width:92%; max-width:720px;
    border:4px solid rgba(255,255,255,0.05);
  }
  .title{font-size:16px; color:var(--accent); text-align:center; margin-bottom:6px}
  .sub{font-size:10px; color:#bcd; text-align:center; margin-bottom:10px}
  .questionBox{background:#041827; padding:10px; border-radius:6px; border:2px solid rgba(255,255,255,0.03); margin-bottom:8px; font-size:12px}
  .pixel{
    image-rendering: pixelated;
    width:12px;height:12px;display:inline-block;
  }
  footer{font-size:10px;color:#89b; margin-top:8px}
  @media (max-width:520px){
    .hud{font-size:9px}
    .btn{padding:6px 8px;font-size:10px}
    .choiceBtn{font-size:10px;padding:6px 8px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div class="box">SCORE: <span id="score">0</span></div>
    <div class="box">LIVES: <span id="lives">5</span></div>
    <div class="box">DEFEATED: <span id="defeated">0</span></div>
    <div class="box">FREQ: <span id="weaponFreq">‚Äî</span> Hz</div>
  </div>

  <canvas id="game" width="360" height="640"></canvas>

  <div class="controls" id="controls">
    <!-- choices will appear here -->
  </div>

  <div style="display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-top:6px">
    <button class="btn" id="startBtn">‚ñ∂Ô∏è START</button>
    <button class="btn" id="pauseBtn">‚è∏Ô∏è PAUSE</button>
    <button class="btn" id="helpBtn">‚ùì HELP</button>
  </div>

  <footer>‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡πÄ‡∏õ‡πá‡∏ô Pixel Retro ‚Äî ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏≠‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏á‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡∏ü‡∏¥‡∏™‡∏¥‡∏Å‡∏™‡πå ‡∏°.5 ‡πÄ‡∏ó‡∏≠‡∏° 1 (‡∏Ñ‡∏•‡∏∑‡πà‡∏ô)</footer>
</div>

<!-- Overlay templates -->
<div id="overlayRoot" style="position:fixed;left:0;top:0;right:0;bottom:0;display:none;align-items:center;justify-content:center;z-index:50"></div>

<script>
/* --------------------------
   CONFIG & DATA (‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢)
   -------------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const W = canvas.width, H = canvas.height;

let state = {
  running:false,
  score:0,
  lives:5,
  defeated:0,
  waves:[],
  enemies:[],
  particles:[],
  anim:0,
  currentQuestion:null,
  awaitingAnswer:false,
  weaponFreq: null
};

// ‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç‡∏ó‡∏µ‡πà‡πÉ‡∏´‡πâ Œª = v / f ‡πÄ‡∏õ‡πá‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏ï‡πá‡∏° (‡∏Ñ‡πà‡∏≤ v, f ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏•‡πâ‡∏ß Œª ‡∏•‡∏á‡∏ï‡∏±‡∏ß)
const easyF = [2,4,5,8,10,20,25];
const easyV = [40,50,60,80,100,120,160,200,250,300];

const bossF = [6,12,15,18,24];
const bossV = [90,108,144,180,216,270];

const enemyTypes = [
  {color:'#ff5d5d', points:60},
  {color:'#ffd66b', points:40},
  {color:'#6bf5ff', points:50},
  {color:'#b86bff', points:70},
  {color:'#4bff9e', points:90, boss:true}
];

// ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏§‡∏©‡∏é‡∏µ (‡∏™‡∏£‡∏∏‡∏õ‡πÅ‡∏ö‡∏ö‡∏™‡∏±‡πâ‡∏ô‡∏à‡∏≤‡∏Å ‡∏°.5 ‡πÄ‡∏ó‡∏≠‡∏°1 ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô)
const theoryQuestions = [
  {q:'‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà (frequency) ‡∏´‡∏°‡∏≤‡∏¢‡∏ñ‡∏∂‡∏á‡∏≠‡∏∞‡πÑ‡∏£?', choices:[
      '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡∏Ç‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏™‡∏±‡πà‡∏ô‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏´‡∏ô‡πà‡∏ß‡∏¢‡πÄ‡∏ß‡∏•‡∏≤',
      '‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏¢‡∏≠‡∏î‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏™‡∏≠‡∏á‡∏¢‡∏≠‡∏î',
      '‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏ó‡∏µ‡πà‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà',
      '‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô'
    ], ans:0},
  {q:'‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (wavelength) ‡∏Ñ‡∏∑‡∏≠‡∏≠‡∏∞‡πÑ‡∏£?', choices:[
      '‡∏£‡∏∞‡∏¢‡∏∞‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡∏Å‡∏±‡∏ô‡∏ö‡∏ô‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏™‡∏≠‡∏á‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ñ‡∏±‡∏î‡∏Å‡∏±‡∏ô',
      '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡∏±‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ',
      '‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô',
      '‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏£‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô'
    ], ans:0},
  {q:'‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô ‡πÇ‡∏î‡∏¢‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÄ‡∏ó‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏° ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£?', choices:[
      '‡∏™‡∏±‡πâ‡∏ô‡∏•‡∏á',
      '‡∏¢‡∏≤‡∏ß‡∏Ç‡∏∂‡πâ‡∏ô',
      '‡∏Ñ‡∏á‡πÄ‡∏î‡∏¥‡∏°',
      '‡πÑ‡∏°‡πà‡∏™‡∏±‡∏°‡∏û‡∏±‡∏ô‡∏ò‡πå'
    ], ans:0},
  {q:'‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡πÄ‡∏™‡∏µ‡∏¢‡∏á‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ä‡∏ô‡∏¥‡∏î‡πÉ‡∏î?', choices:[
      '‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ï‡∏≤‡∏°‡∏¢‡∏≤‡∏ß (longitudinal)',
      '‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ï‡∏≤‡∏°‡∏Ç‡∏ß‡∏≤‡∏á (transverse)',
      '‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ô‡∏¥‡πà‡∏á (standing)',
      '‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡πÅ‡∏°‡πà‡πÄ‡∏´‡∏•‡πá‡∏Å‡πÑ‡∏ü‡∏ü‡πâ‡∏≤'
    ], ans:0},
  {q:'‡πÅ‡∏≠‡∏°‡∏û‡∏•‡∏¥‡∏à‡∏π‡∏î (amplitude) ‡∏ö‡πà‡∏á‡∏ö‡∏≠‡∏Å‡∏≠‡∏∞‡πÑ‡∏£?', choices:[
      '‡∏Ç‡∏ô‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏™‡∏°‡∏î‡∏∏‡∏•',
      '‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏ï‡πà‡∏≠‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ',
      '‡∏£‡∏∞‡∏¢‡∏∞‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏¢‡∏≠‡∏î‡∏Ñ‡∏•‡∏∑‡πà‡∏ô',
      '‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô'
    ], ans:0}
];

// HELP / ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏±‡πâ‡∏ô
const HELP_HTML = `
  <div class="overlay">
    <div class="overlay-inner" style="padding:12px; text-align:left; color:#bcd;">
      <div class="title">‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô ‚Äî Pixel Wave Defender</div>
      <div class="sub">‡πÅ‡∏ô‡∏ß‡∏ï‡∏±‡πâ‡∏á ‚Äî ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏¥‡∏á‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡∏®‡∏±‡∏ï‡∏£‡∏π<br>‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏à‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏±‡πâ‡∏á‡πÄ‡∏ä‡∏¥‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Œª = v / f</div>
      <div style="background:#021827;padding:8px;border-radius:6px;margin-top:8px;font-size:11px">
        <p>‡∏™‡∏π‡∏ï‡∏£‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: Œª = v / f<br>Œª = ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (m), v = ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß (m/s), f = ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà (Hz)</p>
        <p>‡∏ï‡∏≠‡∏ö‡∏ú‡∏¥‡∏î‡∏à‡∏∞‡πÄ‡∏™‡∏µ‡∏¢‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï 1 ‡∏´‡∏ô‡πà‡∏ß‡∏¢ / ‡∏ï‡∏≠‡∏ö‡∏ñ‡∏π‡∏Å‡∏à‡∏∞‡∏¢‡∏¥‡∏á‡πÅ‡∏•‡∏∞‡πÑ‡∏î‡πâ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô</p>
      </div>
      <div style="text-align:center;margin-top:10px">
        <button class="btn" id="closeHelp">‡∏õ‡∏¥‡∏î</button>
      </div>
    </div>
  </div>
`;

/* --------------------------
   PIXEL DRAW HELPERS
   -------------------------- */
function pixRect(x,y,w,h,color){
  // draw pixelated rectangle (coordinates in canvas pixels)
  ctx.fillStyle = color;
  ctx.fillRect(Math.round(x),Math.round(y),Math.round(w),Math.round(h));
}
function drawText(text,x,y,size=8,color='#fff',align='left'){
  ctx.fillStyle = color;
  ctx.font = `${size}px "Press Start 2P"`;
  ctx.textAlign = align;
  ctx.fillText(text, x, y);
}

/* --------------------------
   GAME SPAWN & QUESTIONS
   -------------------------- */
function chooseEnemy(){
  const isBoss = (state.defeated + 1) % 6 === 0; // boss every 6th
  let type = isBoss ? enemyTypes[4] : enemyTypes[Math.floor(Math.random()*4)];
  let f, v;
  if(isBoss){
    f = bossF[Math.floor(Math.random()*bossF.length)];
    v = bossV[Math.floor(Math.random()*bossV.length)];
  } else {
    // ensure v divisible by f for integer lambda
    f = easyF[Math.floor(Math.random()*easyF.length)];
    // pick v from easyV that divisible by f
    const candidates = easyV.filter(val => val % f === 0);
    v = candidates[Math.floor(Math.random()*candidates.length)];
    // fallback
    if(!v){ v = easyV[0]; while(v % f !== 0) v += easyV[0]; }
  }
  const lambda = v / f;
  const enemy = {
    x: 24 + Math.random()*(W-48),
    y: -20,
    vx: (Math.random()-0.5)*0.4,
    vy: 0.6 + Math.random()*0.6,
    color: type.color,
    points: type.points,
    f, v, lambda,
    isBoss: !!type.boss,
    w: 18 + (type.boss?10:0),
    h: 12 + (type.boss?8:0),
    hp: type.boss ? 3 : 1,
    id: Math.random().toString(36).slice(2,8)
  };
  state.enemies.push(enemy);
  // set weapon freq shown to match one of choices (simulate player's weapon tuning)
  state.weaponFreq = f;
  document.getElementById('weaponFreq').textContent = f;
  // now prepare a question (either theory or calculation)
  prepareQuestion(enemy);
}

function prepareQuestion(enemy){
  // 60% ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏õ‡πá‡∏ô not boss, boss ‡∏°‡∏µ‡πÇ‡∏≠‡∏Å‡∏≤‡∏™‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
  const pickCalcProb = enemy.isBoss ? 0.7 : 0.55;
  if(Math.random() < pickCalcProb){
    // calculation question Œª = v / f (‡∏Ñ‡πà‡∏≤‡∏•‡∏á‡∏ï‡∏±‡∏ß)
    const text = `‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô Œª (m) ‡πÇ‡∏î‡∏¢ Œª = v / f\nv = ${enemy.v} m/s, f = ${enemy.f} Hz`;
    const correct = enemy.lambda;
    // generate 3 wrong integer options near correct
    const choices = new Set([correct]);
    while(choices.size < 4){
      const delta = (Math.floor(Math.random()*5)-2); // -2..+2
      let w = correct + delta;
      if(w <= 0) w = correct + Math.abs(delta)+1;
      choices.add(w);
    }
    const arr = shuffle(Array.from(choices));
    state.currentQuestion = {type:'calc', text, choices:arr, correct};
  } else {
    // theory question from bank
    const q = theoryQuestions[Math.floor(Math.random()*theoryQuestions.length)];
    // copy and shuffle
    const arr = shuffle(q.choices.slice());
    state.currentQuestion = {type:'theory', text:q.q, choices:arr, correctIndex: arr.indexOf(q.choices[q.ans])};
  }
  state.awaitingAnswer = true;
  renderChoices();
}

/* --------------------------
   UI: render choices area
   -------------------------- */
const controls = document.getElementById('controls');
function clearChoices(){ controls.innerHTML = ''; }
function renderChoices(){
  clearChoices();
  if(!state.currentQuestion) return;
  const q = state.currentQuestion;
  // show question box
  const qBox = document.createElement('div');
  qBox.className = 'questionBox';
  qBox.style.width='100%';
  qBox.innerHTML = `<div style="font-size:11px;color:#ffeeaa;margin-bottom:8px">${escapeHtml(q.text).replace(/\n/g,'<br>')}</div>`;
  controls.appendChild(qBox);
  // choices buttons
  q.choices.forEach((ch,idx)=>{
    const b = document.createElement('button');
    b.className = 'choiceBtn';
    b.style.minWidth='160px';
    b.style.margin='4px';
    b.innerText = (q.type==='calc'? `Œª = ${ch} m` : ch);
    b.onclick = ()=> onAnswer(ch, idx, b);
    controls.appendChild(b);
  });
}

/* --------------------------
   ANSWER HANDLING
   -------------------------- */
function onAnswer(choice, idx, btnEl){
  if(!state.awaitingAnswer) return;
  state.awaitingAnswer = false;
  const q = state.currentQuestion;
  let correct = false;
  if(q.type==='calc') {
    correct = (Math.abs(choice - q.correct) < 1e-9);
  } else {
    correct = (idx === q.correctIndex);
  }
  // mark buttons
  const btns = Array.from(document.querySelectorAll('.choiceBtn'));
  btns.forEach(b=>{
    b.disabled = true;
  });
  if(correct){
    btnEl.classList.add('correct');
    // find nearest enemy and damage
    const en = nearestEnemy();
    if(en){
      createPixelBurst(en.x,en.y,en.color,12);
      en.hp--;
      if(en.hp <= 0){
        destroyEnemy(en, true);
      } else {
        // boss damaged, small score
        state.score += Math.round(en.points / 2);
      }
    } else {
      state.score += 10;
    }
  } else {
    btnEl.classList.add('wrong');
    // penalty
    state.lives--;
    state.score = Math.max(0, state.score - 15);
    createPixelBurst(W/2, H-80, '#ff6b6b', 10);
    // flash wrong on nearest button (reveal correct one)
    setTimeout(()=> {
      // highlight correct among buttons
      const correctIdx = (q.type==='calc') ? q.choices.indexOf(q.correct) : q.correctIndex;
      if(typeof correctIdx === 'number' && btns[correctIdx]) btns[correctIdx].classList.add('correct');
    }, 400);
    if(state.lives <= 0){
      endGame();
      return;
    }
  }
  updateHUD();
  // after short delay spawn next enemy if alive else immediate
  setTimeout(()=> {
    // if no enemies or nearest dead, spawn new
    if(state.enemies.length < 3) chooseEnemy();
    // allow next question when next enemy spawns (handled in chooseEnemy)
  }, 700);
}

/* --------------------------
   ENEMY / PARTICLE / COLLISIONS
   -------------------------- */
function nearestEnemy(){
  if(state.enemies.length===0) return null;
  let best = null, bestD=1e9;
  for(const e of state.enemies){
    const d = Math.hypot(e.x - W/2, e.y - (H-80));
    if(d < bestD){ bestD = d; best = e; }
  }
  return best;
}
function destroyEnemy(enemy, killedByPlayer){
  // remove enemy
  const idx = state.enemies.findIndex(e=>e.id===enemy.id);
  if(idx>=0) state.enemies.splice(idx,1);
  // add particles
  createPixelBurst(enemy.x, enemy.y, enemy.color, 18);
  if(killedByPlayer){
    state.score += enemy.points;
    state.defeated++;
  }
  updateHUD();
  // spawn new after slight delay
  setTimeout(()=>{ if(state.enemies.length < 3) chooseEnemy(); }, 600);
}

function createPixelBurst(x,y,color,count=12){
  for(let i=0;i<count;i++){
    state.particles.push({
      x:x + (Math.random()-0.5)*18,
      y:y + (Math.random()-0.5)*18,
      vx:(Math.random()-0.5)*2.4,
      vy:(Math.random()-0.5)*2.4,
      life:30 + Math.random()*30,
      color
    });
  }
}

/* --------------------------
   GAME LOOP
   -------------------------- */
function update(){
  if(!state.running) return;
  state.anim += 1;
  // spawn occasionally
  if(Math.random() < 0.01 && state.enemies.length < 3) chooseEnemy();
  // update enemies
  for(let i=state.enemies.length-1;i>=0;i--){
    const e = state.enemies[i];
    e.x += e.vx;
    e.y += e.vy;
    // bounce at sides
    if(e.x < 12) { e.x = 12; e.vx *= -1 }
    if(e.x > W-12) { e.x = W-12; e.vx *= -1 }
    // if pass bottom - harm player
    if(e.y > H+40){
      // remove
      state.enemies.splice(i,1);
      state.lives = Math.max(0, state.lives-1);
      createPixelBurst(W/2, H-80, '#ff8a8a', 10);
      updateHUD();
      if(state.lives <= 0) { endGame(); return; }
    }
  }
  // particles
  for(let i=state.particles.length-1;i>=0;i--){
    const p = state.particles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.02;
    p.vx *= 0.99;
    p.vy *= 0.99;
    p.life--;
    if(p.life <= 0) state.particles.splice(i,1);
  }
  // auto-fire wave visual (optional)
  // render
  render();
  requestAnimationFrame(update);
}

/* --------------------------
   RENDERING: pixel art style
   -------------------------- */
function render(){
  // clear
  ctx.fillStyle = '#02101a';
  ctx.fillRect(0,0,W,H);
  // background starfield (simple)
  for(let i=0;i<40;i++){
    const sx = (i*73 + (state.anim*2)) % W;
    const sy = ((i*31 + state.anim*3) % H);
    pixRect((sx)%W, (sy)%H, 1,1, (i%5==0?'#99ddff':'#44556a'));
  }
  // draw enemies (pixel blocks)
  for(const e of state.enemies){
    // color block body (multi-color stripes)
    for(let yy=0; yy<e.h; yy+=4){
      const shade = shadeColor(e.color, -yy*1.6);
      pixRect(e.x - e.w/2, e.y - e.h/2 + yy, e.w, 3, shade);
    }
    // eyes (pixel)
    pixRect(e.x-4, e.y-6, 3,3, '#000');
    pixRect(e.x+2, e.y-6, 3,3, '#000');
    // hp bar
    if(e.isBoss){
      const barW = 40;
      pixRect(e.x - barW/2, e.y - e.h/2 - 8, barW, 4, '#222');
      pixRect(e.x - barW/2, e.y - e.h/2 - 8, Math.round(barW * (e.hp/3)), 4, '#ff8a8a');
    }
  }
  // draw player ship at bottom center (pixel)
  const px = W/2, py = H-72;
  // body
  pixRect(px-12, py-6, 24, 6, '#55d6ff');
  pixRect(px-10, py-12, 20, 6, '#ffde6b');
  pixRect(px-6, py-18, 12, 6, '#ff9e56');
  // cockpit
  pixRect(px-4, py-14, 8, 4, '#05323b');
  // engine flames if anim
  if(state.anim%6 < 3){
    pixRect(px-10, py+2, 4, 6, '#ff9e56');
    pixRect(px+6, py+2, 4, 6, '#ff9e56');
  }
  // draw waves (visual) - any particle in waves array
  // draw particles
  for(const p of state.particles){
    pixRect(p.x, p.y, 2,2, p.color);
  }
  // HUD overlay text inside canvas
  drawText(`Œª = v / f`, 8, 14, 9, '#ffdba6', 'left');
  drawText(`‡∏™‡∏π‡∏ï‡∏£‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç`, W-8, 14, 9, '#a6d8ff', 'right');
}

/* --------------------------
   UTIL & HELPERS
   -------------------------- */
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a }

function updateHUD(){
  document.getElementById('score').textContent = state.score;
  document.getElementById('lives').textContent = state.lives;
  document.getElementById('defeated').textContent = state.defeated;
  document.getElementById('weaponFreq').textContent = state.weaponFreq || '‚Äî';
}

/* shade color helper */
function shadeColor(hex, percent) {
  // hex like #rrggbb
  const f = hex.slice(1);
  const t = percent < 0 ? 0 : 255;
  const p = Math.abs(percent) / 100;
  const R = parseInt(f.substring(0,2),16);
  const G = parseInt(f.substring(2,4),16);
  const B = parseInt(f.substring(4,6),16);
  const newR = Math.round((t - R)*p) + R;
  const newG = Math.round((t - G)*p) + G;
  const newB = Math.round((t - B)*p) + B;
  return `rgb(${newR},${newG},${newB})`;
}

/* escape html for question text */
function escapeHtml(s){ return s.replace(/[&<>"']/g, function(m){ return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m] }) }

/* --------------------------
   GAME CONTROL
   -------------------------- */
document.getElementById('startBtn').addEventListener('click', ()=>{
  if(state.running) resetGame(); else startGame();
});
document.getElementById('pauseBtn').addEventListener('click', ()=>{
  state.running = !state.running;
  if(state.running){
    document.getElementById('pauseBtn').innerText = '‚è∏Ô∏è PAUSE';
    update();
  } else {
    document.getElementById('pauseBtn').innerText = '‚ñ∂Ô∏è RESUME';
  }
});
document.getElementById('helpBtn').addEventListener('click', ()=> showOverlay(HELP_HTML));

function startGame(){
  // reset
  state.running = true;
  state.score = 0; state.lives = 5; state.defeated = 0;
  state.enemies = []; state.particles = []; state.currentQuestion = null; state.awaitingAnswer=false;
  state.weaponFreq = '‚Äî';
  updateHUD();
  // spawn a couple enemies
  chooseEnemy(); chooseEnemy();
  // set button state
  document.getElementById('startBtn').innerText = '‚Üª RESTART';
  update();
}

function resetGame(){
  // restart
  state.running = false;
  setTimeout(()=> startGame(), 150);
}

function endGame(){
  state.running = false;
  // overlay with summary and learning snippet
  const overlay = document.createElement('div');
  overlay.className = 'overlay';
  overlay.style.maxWidth='750px';
  overlay.innerHTML = `
    <div style="text-align:center">
      <div class="title">üí• GAME OVER</div>
      <div class="sub">‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢: ${state.score} &nbsp;|&nbsp; ‡∏õ‡∏£‡∏≤‡∏ö: ${state.defeated}</div>
      <div style="background:#021827;padding:10px;border-radius:8px;margin-top:8px;font-size:11px;color:#bcd">
        <div style="font-weight:bold;color:#ffd07a">‡∏™‡∏£‡∏∏‡∏õ‡∏™‡∏±‡πâ‡∏ô ‡πÜ ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô</div>
        <div style="margin-top:6px">
          ‡∏™‡∏π‡∏ï‡∏£‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç: Œª = v / f<br>
          Œª = ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (m), v = ‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô (m/s), f = ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà (Hz)<br>
          ‡∏ñ‡πâ‡∏≤‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ñ‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ç‡∏∂‡πâ‡∏ô‡πÅ‡∏ï‡πà‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏Ñ‡∏á‡∏ó‡∏µ‡πà ‚Üí ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡∏™‡∏±‡πâ‡∏ô‡∏•‡∏á
        </div>
      </div>
      <div style="margin-top:10px"><button class="btn" id="playAgain">‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á</button></div>
    </div>
  `;
  showOverlayElement(overlay);
  document.getElementById('playAgain').addEventListener('click', ()=>{ hideOverlay(); startGame(); });
}

/* --------------------------
   OVERLAY helpers
   -------------------------- */
const overlayRoot = document.getElementById('overlayRoot');
function showOverlay(html){
  overlayRoot.style.display='flex';
  overlayRoot.innerHTML = `<div class="overlay">${html}</div>`;
  // attach close
  const close = document.getElementById('closeHelp');
  if(close) close.onclick = ()=> hideOverlay();
}
function showOverlayElement(el){
  overlayRoot.style.display='flex';
  overlayRoot.innerHTML = '';
  overlayRoot.appendChild(el);
}
function hideOverlay(){ overlayRoot.style.display='none'; overlayRoot.innerHTML = ''; }

/* --------------------------
   INIT: bind close overlay clicking background
   -------------------------- */
overlayRoot.addEventListener('click', (e)=>{
  if(e.target === overlayRoot) hideOverlay();
});

/* --------------------------
   STARTUP: draw initial screen
   -------------------------- */
function drawTitleScreen(){
  ctx.fillStyle = '#011022';
  ctx.fillRect(0,0,W,H);
  drawText('PIXEL WAVE DEFENDER', W/2, 100, 10, '#ffdd88', 'center');
  drawText('‡πÉ‡∏ä‡πâ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏£‡∏π‡πâ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏Ñ‡∏•‡∏∑‡πà‡∏ô‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏¢‡∏≤‡∏ß‡∏Ñ‡∏•‡∏∑‡πà‡∏ô', W/2, 140, 7, '#a6d8ff', 'center');
  // pixel ship preview
  for(let yc=0; yc<5; yc++){
    for(let xc=0; xc<20; xc++){
      const x = 60 + xc*6; const y = 180 + yc*6;
      if((xc+yc)%3===0) pixRect(x,y,4,4, ['#ff5d5d','#ffd66b','#6bf5ff','#b86bff'][Math.floor(Math.random()*4)]);
    }
  }
  drawText('‡∏Å‡∏î START ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏£‡∏¥‡πà‡∏°', W/2, H-60, 8, '#ffd07a', 'center');
}
drawTitleScreen();

/* --------------------------
   Helper: simple shuffle test spawn
   -------------------------- */
function seedStartEnemiesForDemo(){
  // nothing
}

/* --------------------------
   Utilities: simple RNG / auto start demo
   -------------------------- */

/* initialize HUD */
updateHUD();

</script>
</body>
</html>
